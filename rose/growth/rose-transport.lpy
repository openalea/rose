from copy import deepcopy

nbEntity = 6
nbLatEntity = 3

min_level = 2
max_level = 10

active_transport_coef = 0.1 # T
diffusion_coef = 0.1 # D
auxin_synth_coef = 5. # \rho (c_i)
# auxin_synth_coef = 0.5 # \rho (c_i)
auxin_degrad_coef = 0.1 # \delta_a (a)
pin_wall_coeff = 1. # k^+
wall_pin_coeff = 1. # k^-
pin_degrad_coeff = 1 # \delta_p (a) 
pin_synth_coeff = 0.01 
convergence_delay = 25
ramif_threshold = 3

max_pin = 10

dt = 0.05

lwidth = 0.02

def h(flux) :
  if flux > 0.:  return 0.
  h_coef = 7.5
  n = 3
  fluxn = abs(flux) ** n
  return h_coef * (fluxn / (1.3**n + fluxn))

def g(auxin):
  g_coef = 1.
  return g_coef * auxin

def txt(val):
    return str(round(val,2))[:5]

class OrganParameter(ParameterSet):
  def __init__(self, auxin, sugar, order = 0, first = False, auxin_synth_coef= 0):
#    """ State variable of a compartment.
#    
#    Parameters
#    ==========
#      - auxin : auxin concentration
#      - sugar : sugar concentration
#      - pin: PIN concentration in the organ not affected to the membranes
#      - pin_up = 0, # PIN surfacic concentration on upward membrane
#      - pin_down =0, # PIN surfacic concentration on downard membrane
#      pin_lat=0 # PIN surfacic concentration on lateral membrane
#      flux_up = 0 # flux coming from upward membrane (positive if entering the cell)
#      flux_down =0, # flux coming from downard membrane
#      flux_lat=0 # flux coming from lateral membrane
#    """
#    
    pin=0 # PIN concentration in the organ not affected to the membranes
    pin_up = 0 # PIN surfacic concentration on upward membrane
    pin_down =0 # PIN surfacic concentration on downard membrane
    pin_lat=0 # PIN surfacic concentration on lateral membrane
    flux_up = 0 # flux coming from upward membrane (positive if entering the cell)
    flux_down =0 # flux coming from downard membrane
    flux_lat=0 # flux coming from lateral membrane
    
    ParameterSet.__init__(self, auxin=auxin, sugar=sugar, pin=pin, pin_up=pin_up, 
                          pin_down=pin_down, pin_lat=pin_lat,flux_up=flux_up, 
                          flux_down=flux_down, flux_lat=flux_lat,first=first,order=order,
                          auxin_synth_coef = auxin_synth_coef)

class ApexParameter(OrganParameter):
  def __init__(self, auxin, sugar, nbentity, time = 0, order = 0, auxin_synth_coef = auxin_synth_coef):
    OrganParameter.__init__(self, auxin, sugar, order, auxin_synth_coef)
    self.time = time
    self.nbentity = nbentity

def process_transport(p, pu = None, pd = None, pl = None):
  if not pl is None: 
    if len(pl) == 0: pl = None
    else: pl = pl[0]
  
  a = p.auxin
  fu, fd, fl  = p.flux_up, p.flux_down, p.flux_lat
  pin, pinu, pind, pinl = p.pin, p.pin_up , p.pin_down, p.pin_lat
  
  if pu: au =  pu.auxin
  if pd: ad =  pd.auxin
  if pl: al = pl.auxin
    
  p = deepcopy(p)
  auxin_synth_coef = p.auxin_synth_coef
  
  # fluxs are counted as positive when they get into p
  net_flux = 0
  if pu:
    p.flux_up = active_transport_coef * (pu.pin_down * au - p.pin_up*a) + \
                diffusion_coef * (au - a)
    net_flux += p.flux_up 
  if pd:
    if pd.order < p.order:
      pdpin = pd.pin_lat
    else:
      pdpin = pd.pin_up
    p.flux_down = active_transport_coef * (pdpin*ad - p.pin_down * a) + \
                    diffusion_coef * (ad - a)
    net_flux +=  p.flux_down

  if pl:
    p.flux_lat = active_transport_coef * (pl.pin_down*al - p.pin_lat * a) + \
              diffusion_coef * (al - a)                  
    net_flux += p.flux_lat
  
  # rate of change of auxin
  ra = auxin_synth_coef # auxin synthesis
  ra += - auxin_degrad_coef * a # auxin degradation
  ra += net_flux # sum phi_ji sij / vi
  
  p.auxin += ra*dt 
  #assert 0. <= p.auxin <= 10. 
  # dPiu/dt, dPid/dt => rpinu, rpind
  hu = h(fu)
  hd = h(fd)
  hl = h(fl)
  
  if PIN_COMPETITION:
    
    sh = hu+hd+hl
    if abs(sh) < 1e-5 : sh = 1 
    hu /= sh
    hd /= sh
    hl /= sh
    
    net_rpin = 0
    if pu:
      rpinu = hu*pin_wall_coeff*pin - wall_pin_coeff*pinu 
      p.pin_up += rpinu*dt
      net_rpin += rpinu
    
    if pd:
      rpind = hd*pin_wall_coeff*pin - wall_pin_coeff*pind 
      p.pin_down += rpind*dt
      net_rpin += rpind
    
    if pl:
      rpinl = hl*pin_wall_coeff*pin - wall_pin_coeff*pinl
      p.pin_lat += rpinl*dt
      net_rpin += rpinl
  else:
    net_rpin = 0
    if pu:
      rpinu = hu + pin_synth_coeff - pin_degrad_coeff*p.pin_up 
      p.pin_up += rpinu*dt
      net_rpin += rpinu
    
    if pd:
      rpind = hd + pin_synth_coeff - pin_degrad_coeff*p.pin_down 
      p.pin_down += rpind*dt
      net_rpin += rpind
    
    if pl:
      rpinl = hl + pin_synth_coeff - pin_degrad_coeff*p.pin_lat
      p.pin_lat += rpinl*dt
      net_rpin += rpinl
  
  # CASE 1: 
  #   dPi / dt : No limit for produced pin for the moment
  
  # CASE 2: 
  rpin = g(a) - pin_degrad_coeff*pin - net_rpin
  p.pin += rpin*dt
  
  #if (p.auxin < ramif_threshold) and not is_ramif:
  #  produce I(p) [ + I(OrganParameter(max_level,0)) ]
  # else:
  return p



module Apex(p,t,o) 

Axiom: _(2)I(OrganParameter(min_level,0,first=True)) Apex(nbEntity,0,0)

derivation length: 1000
ignore: +-
production:


I(pd) < I(p) > x( [ I(pl) ] ) or(I(pu1),Apex( :
  p.auxin_synth_coef = 0
  p = process_transport(p,pu, pd, pl)
  is_ramified = (len(pl) != 0)
  if (p.auxin < ramif_threshold) and p.order == 0 and not is_ramified:
    produce I(p) [ -(90) I(OrganParameter(max_level, 0, order = p.order+1)) Apex(nbLatEntity-1,1, p.order+1) ]
  else:
    produce I(p)

I(pd) < I(p) > [ I(pl) ] x(Apex(a0,a1,a2)) :
  p.auxin_synth_coef = auxin_synth_coef if len(a0) == 1 else 0
  p = process_transport(p,None, pd, [pl])
  produce I(p)


I(p) >  I(pu): # The root compartment
  p = process_transport(p,pu, None, None)
  p.auxin = min_level
  produce I(p)


I(pd) < I(p) > x(Apex(a0,a1,a2)) :
  p.auxin_synth_coef = auxin_synth_coef if len(a0) == 1 else 0
  p = process_transport(p,None, pd, None)
  produce I(p)


Apex(0,t,o) --> T

Apex(x,t,o) :
  if t % convergence_delay == 0:
    if x == 1:
      auxin = max_level
      sugar = 0.
    else:
      auxin = max_level
      sugar = 0.
    p = OrganParameter(auxin, sugar, order = o)
    nproduce I(p)
    if o == 0: 
         nproduce [ -(90) I(OrganParameter(max_level, 0, order = p.order+1)) Apex(nbLatEntity-1,1, p.order+1) ] 
    produce Apex(x-1,t+1,o)
  else:
    produce Apex(x,t+1,o)




interpretation:
maximum depth: 4
I(pd) < [ -(90) I(p) :
  
   nproduce [ | f(1.5)+(90)f(1.5)
   draw_internode(p)

I(p) :
   draw_internode(p)


B(x,h) --> ,(20) _(lwidth) f(-lwidth/2) +(90) F((x+lwidth)/2.)@O -(90) F(h+lwidth) @O -(90)F(x+lwidth) @O -(90)F(h+lwidth) @O -(90)F((x+lwidth)/2.)-(90)f(h+lwidth/2)


G(l) --> K(l,l)
K(l,h) --> f(h/2.){+(90)f(l/2.).+(90)f(h).+(90)f(l).+(90)f(h).}

Apex(x,t,o) --> ,(21) f(0.1) @O(0.3)
T --> ,(0) f(0.3) @O(0.6)
endlsystem

def draw_internode(p):
   pinupr = 0.5 * p.pin_up /max_pin
   pindownr = 0.5 * p.pin_down /max_pin
   pinlatr = 0.5 * p.pin_lat /max_pin
   rfd = abs(p.flux_down)*0.05 +0.01
   rfu = abs(p.flux_up)*0.05 +0.01
   rfl = abs(p.flux_lat)*0.05 +0.01
   tl = 3
   nproduce  [
   if not p.first:
     tl = 2.5
     nproduce ,(20 if p.flux_down > 0 else 21) _(rfd) F(0.5) 
   nproduce  [,(1) f(pindownr/2) K(2,pindownr)] 
   nproduce [,(1)-(90)f(1+pinlatr/2)+(90)f(1+(pinupr+pindownr)/2)K(pinlatr,2+pinupr+pindownr)] # lateral pin box
   nproduce [-(90)f(pinlatr/2)+(90)B(2+pinlatr,2+pinupr+pindownr)] f(2+pinupr+pindownr) # black box
   nproduce [ ,(1) | f(pinupr/2) K(2,pinupr) ]  # up pin box
   nproduce   ,(20 if p.flux_up > 0 else 21) _(rfu) F(0.5) ] f(pindownr + (1.5 if not p.first else 1))
   if abs(p.flux_lat) > 1e-3 :
     nproduce [-(90) f(1+pinlatr),(20 if p.flux_lat > 0 else 21) _(rfl) F(0.5)
     if p.flux_lat < 0:
       nproduce  [,(10)|f(0.2)|_(rfl+0.2)F(0.4,rfl)]
     elif p.flux_lat > 0:
       nproduce  [,(10)|f(0.2)|_(rfl)F(0.4,rfl+0.2)]
     nproduce ]
     
   if p.first :
     bgcol = 6
   elif p.auxin_synth_coef == 0:
     bgcol = 16
   else: 
     bgcol = 22
    
   nproduce  [,(bgcol)G(2)]
   nproduce  [^(90)f(0.01)&(90),(15)G(2.*p.auxin/max_level)]
   
   nproduce  f(1.5+pinupr)
   if p.flux_up < 0:
     nproduce  [,(10)|f(0.2)|_(rfu+0.2)F(0.4,rfu)]
   elif p.flux_up > 0:
     nproduce  [,(10)|f(0.2)|_(rfu)F(0.4,rfu+0.2)]
  
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (39,0,0) , diffuse = 4.61538 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_1 = pgl.Material("Color_1" , ambient = (40,5,0) , diffuse = 4.518 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (41,10,0) , diffuse = 4.42061 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (43,15,0) , diffuse = 4.32322 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (44,21,0) , diffuse = 4.22583 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (46,26,0) , diffuse = 4.12845 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (47,31,0) , diffuse = 4.03106 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (48,37,0) , diffuse = 3.93367 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (50,42,0) , diffuse = 3.83628 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (51,47,0) , diffuse = 3.7389 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (53,53,0) , diffuse = 3.64151 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_15 = pgl.Material("Color_15" , ambient = (0,0,255) , diffuse = 0.627451 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (157,158,205) , diffuse = 0 , specular = (0,0,0) , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 26.6667 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (0,95,0) , diffuse = 0 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (128,193,96) , diffuse = 0 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	scalars = [('PIN_COMPETITION', False)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] is None : context[s[0]] = s[1]
__copyright__ = 'open-source GPL'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'F. Boudon, C. Godin'
