from copy import deepcopy
from numpy import arange
import transport_eq
reload(transport_eq)
from transport_eq import *
import utils
reload(utils)
from utils import *
from openalea.plantgl.all import *

"""
Modeling of the Sugar/Auxin ratio effect on the CK/SL ratio effect hat itself induce the brc1 level.
By default, A ratio of S/A of 1 gives stable ratio of CK/SL.
If we increment Sugar to 15, then CK is increased, SL decrease and BRC1 also.
If we decrease Auxin (to 5), the opposite situation occurs.
"""


mylpyimport(globals(), 'plotcurve','plotCurve','draw_internode')


if not 'AUXIN' in globals():
  AUXIN = 2.5 if auxin else 0
if not 'SUGAR' in globals():
  if sugar == 0: SUGAR = 0
  elif sugar == 1 : SUGAR = 1
  elif sugar == 2 : SUGAR = 2.5


# to have rapid burst:
initial_auxin_level = AUXIN # float(2.5) # instead of 10
initial_sugar_level = SUGAR # float(0) # float(SUGAR)
print initial_auxin_level, initial_sugar_level

auxin_synth_coef = 0
auxin_decay_coef = 0


# to have slower burst
ck_init  = 0
ck_synth_coef = 0.11 # instead of 0.5
ck_base_synth_coef = 0.1
ck_decay_coef = 0.1
ck_base_decay_coef = 0.1

sl_init  = 0
sl_synth_coef = 0.03
sl_base_synth_coef = 0.1
sl_decay_coef = 0.1


slp_init = 1
slp_synth_coef = 0.3
slp_decay_coef = 0.1

pin_init = 0.5

init_brc1 = 1
brc1_synth_coef = 0.2
brc1_base_synth_coef = 0.1
brc1_decay_coef = 0.05
brc1_base_decay_coef = 0.01


class SimuParameters:
  innate_polarity = True
  ACTIVATION = False
  with_auxin_max_level = True
    
  default_active_transport_coef = 0.5 # T
  diffusion_coef = 0.2 # D
  
  # axin synthesis and degradation coefficient
  default_auxin_synth_coef = 0.5 # \rho (c_i)
  default_auxin_decay_coef = 0.1 # v (a)
  
  default_pin_synth_coeff = 0.0 # rho_0
  pin_decay_coeff = 10  # \mu
    
  # parameter of the flux feedback function
  h_coef = 7.5 # rho_i->j in the paper
  # non linear exponent of the flux feedback function
  n = 3
  # hill saturation coef
  K = 1.3
  
  dt = 0.05
  
  default_sugar = 10.
  
  default_ck = 0.
  default_ck_synth_coef = 0.5 # depend on sugar
  default_ck_base_synth_coef = 0.1
  default_ck_decay_coef = 0.5
  default_ck_base_decay_coef = 0.1
  ck_diffusion_coef = 0.5
  
  default_sl = 10
  default_sl_synth_coef = 0.1
  default_sl_base_synth_coef = 0.0
  default_sl_decay_coef = 0.1
  sl_diffusion_coef = 0.5
  
  default_slp = 1
  default_slp_synth_coef = 0.5
  default_slp_decay_coef = 0.05
  
  default_pin_slp_interaction = 0
  default_auxin_synth_coef = 1
  
  brc1_auxin_interaction = 0.05
  
  DEGRADATION = DEGRADATION
  DIFFUSION   = DIFFUSION

lateral_bud_auxin_synth_coef = 0.3

set_simu_parameters(SimuParameters())

# Graphical parameters 
max_pin_value = 1
max_auxin_value =  max(2*max(initial_auxin_level, initial_sugar_level),30)
lwidth = 0.02


def txt(val):
    return str(round(val,2))[:5]


flux_threshold = 10
def activation_flux_th(p):
  return p.flux_down > flux_threshold

initial_view= 0
ckvalues = None
slvalues = None
slpvalues = None
brc1values = None

def Start():
  global ckvalues, slvalues, slpvalues, brc1values
  ckvalues   = []
  slvalues   = []
  slpvalues  = []
  brc1values = []

def StartEach(lstring):
    #if getIterationNb() == 200:
    #  entity = lstring[1]
    #  assert entity.name == 'Medium'
    #  entity.p.auxin_decay_coef = later_root_auxin_decay_coef
    pass

propstodraw= ['sugar','auxin','ck','sl','slp','brc1']
propcolors = [10,21,17,18,15,0]
propcolorm = [context().turtle.getMaterial(c).diffuseColor() for c in propcolors]
propcolorm = [(c.red,c.green,c.blue) for c in propcolorm]
propcolorm = [(0 if c[0] == 0 else 255,0 if c[1] == 0 else 255,0 if c[2] == 0 else 255) for c in propcolorm]

def EndInterpretation():
   px,py = 0.7, 0.7
   nproduce @M(0.9,0.9) Label(str(getIterationNb()))
   for i,prop in enumerate(propstodraw):
     nproduce @M(px,py-0.11*i-0.01,0.1) ,(20) _(0.06) @B(0.12) @M(px,py-0.11*i) SetColor(propcolorm[i][0],propcolorm[i][1],propcolorm[i][2])  _(0.05) @B(0.1)  @M(px+0.1,py+0.04-0.11*i) ,(20) Label(prop,16)

wscale = 0.7
pinit = (-0.0,-0.5)

def draw_property(p, prop, pos):
  val = 0.5*getattr(p,prop)/max_auxin_value
  pos = sp(pos)
  w = 0.1*wscale
  col = propcolorm[propstodraw.index(prop)]
  nproduce [ ,(20) @M(pos[0],pos[1]-0.01,0.1) _(w+(0.02*wscale)) @B(val+0.02) 
  if abs(val) > 1e-5: nproduce @M(pos[0],pos[1]) _(w) SetColor(col[0],col[1],col[2]) @B(val)  
  nproduce ]
  nproduce [ ,(0) @M(pos[0]-0.07-len(prop)*0.01 ,pos[1]-0.05,-0.5) Label(prop+' : %.4f' % getattr(p,prop),16) ]


def sp(pos):
  return Vector2([pinit[i] + pos[i]*wscale for i in xrange(2)])
  
module Apex(p) , I(p), Root(p), Medium(p), LApex(p) , LF(t)


Axiom: 
  nproduce @2D _(2) 
  nproduce  I(ApexParameter(auxin=initial_auxin_level, 
                            sugar = initial_sugar_level,
                            auxin_synth_coef = auxin_synth_coef,
                            auxin_decay_coef = auxin_decay_coef,
                            ck = ck_init,
                            ck_synth_coef = ck_synth_coef,
                            ck_base_synth_coef = ck_base_synth_coef,
                            ck_decay_coef = ck_decay_coef,
                            ck_base_decay_coef = ck_base_decay_coef,
                            sl = sl_init,
                            sl_synth_coef = sl_synth_coef,
                            sl_base_synth_coef = sl_base_synth_coef,
                            sl_decay_coef=sl_decay_coef,
                            slp = slp_init,
                            slp_synth_coef = slp_synth_coef,
                            brc1=init_brc1, 
                            brc1_synth_coef=brc1_synth_coef,
                            brc1_base_synth_coef=brc1_base_synth_coef,
                            brc1_decay_coef=brc1_decay_coef,
                            brc1_base_decay_coef=brc1_base_decay_coef)) 


nbsteps = 5000

derivation length: nbsteps
ignore: +-
production:

I(p)  :
  p = process_transport(p, None, None, None,verbose=False)
  ckvalues.append(p.ck)
  slvalues.append(p.sl)
  slpvalues.append(p.slp)  
  brc1values.append(p.brc1)
  produce I(p)







interpretation:
maximum depth: 4





I(p) :
  if getIterationNb() >= 1:
    x = range(getIterationNb()+1)
    #plotCurve((x,ckvalues),pos = (-0.9,0.52),dim = (0.5, 0.45),  xextend=(0,nbsteps))
    #nproduce [@M(-0.63,0.5) Label('CK')]
    #plotCurve((x,slvalues),pos = (-0.3,0.52),dim = (0.5, 0.45),  xextend=(0,nbsteps))
    #nproduce [@M(-0.03,0.5) Label('SL')]
    #plotCurve((x,slpvalues),pos = (0.3,0.52),dim = (0.5, 0.45),  xextend=(0,nbsteps))
    #nproduce [@M(0.57,0.5) Label('SLp')]
    #plotCurve((x,brc1values),pos = (-0.3,0.02),dim = (0.5, 0.45),  xextend=(0,nbsteps))
    #nproduce [@M(-0.03,0.0) Label('BRC1')]
    plotCurve(curves=[([0,getIterationNb()],[p.sugar,p.sugar]),([0,getIterationNb()],[p.auxin,p.auxin]),(x,ckvalues),(x,slvalues),(x,slpvalues),(x,brc1values)],curvescolors = propcolorm, pos = (-0.4,0.1),dim = (0.8, 0.8),  xextend=(0,nbsteps) , yextend = (-1, 5))
   
  posauxin = Vector2(-0.7,0.4)
  possugar = Vector2(-0.7,-0.4)
  posck = Vector2(0.1,-0.4)
  possl = Vector2(-0.2,0.4)
  posslp = Vector2(0.3,0.4)
  posbrc1 = Vector2(0.8,0)
  posmidslslp = (possl+posslp)/2.
  draw_property(p,'auxin',posauxin)  
  draw_property(p,'sugar',possugar)  
  draw_property(p,'ck',posck)  
  draw_property(p,'sl',possl)  
  draw_property(p,'slp',posslp)  
  draw_property(p,'brc1',posbrc1)
  RightAnchor = (0.14,0.)
  LeftAnchor  = (-0.14,0.)
  TopAnchor  = (0,0.1)
  BotAnchor  = (0,-0.1)
  nproduce ,(14) Arrow(posauxin + RightAnchor, possl + LeftAnchor)
  nproduce  Arrow(possugar+ RightAnchor, posck + LeftAnchor)
  nproduce  Arrow(possl + RightAnchor, posslp + LeftAnchor)
  nproduce  NotArrow(posauxin + RightAnchor, posck + LeftAnchor)
  nproduce  Arrow(posslp + RightAnchor,posbrc1 + LeftAnchor)
  nproduce  NotArrow(posck + RightAnchor,posbrc1 + LeftAnchor)
  intpoint = (posmidslslp[0], (possugar[1]+posmidslslp[1])/2)
  nproduce Line( possugar + RightAnchor, intpoint) NotArrow(intpoint,posmidslslp+BotAnchor )



Arrow(start,target):
  start = sp(start)
  target = sp(target)
  dir = (target-start)
  l = dir.normalize()
  ratio = 0.8
  ptarget = start+ dir*ratio*l
  #nproduce [@M(start[0],start[1],-0.1) ,(0) @O(0.02)]
  #nproduce [@M(target[0],target[1],-0.1) ,(0) @O(0.02)]
  
  nproduce [@M(start[0],start[1]) _(0.01*wscale) OLineTo(0,ptarget[0],ptarget[1]) _(0.03*wscale) F(l*(1-ratio),0)]

NotArrow(start,target):
  start = sp(start)
  target = sp(target)
  dir = (target-start)
  l = dir.normalize()
  ratio = 0.85
  ptarget = start+ dir*ratio*l
  w = 0.07*wscale  
  nproduce [@M(start[0],start[1]) _(0.01*wscale) OLineTo(0,ptarget[0],ptarget[1]) _(w) F(l*(0.05))]

Line(start,target):
  start = sp(start)
  target = sp(target)
  nproduce [@M(start[0],start[1]) _(0.01*wscale) OLineTo(0,target[0],target[1])]

Flower(p):
   col = 0
   if not p.active: col = 9
   produce ,(col) f(0.1 if  not p.active else 0.6) @O(0.3 if not p.active else 0.6)



##############

T --> ,(0) f(0.3) @O(0.6)




E --> @2D @M(0.9,0.9 )Label( str(getIterationNb()) )

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (255,0,0) , diffuse = 0.807843 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_1 = pgl.Material("Color_1" , ambient = (40,5,0) , diffuse = 4.518 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (41,10,0) , diffuse = 4.42061 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (43,15,0) , diffuse = 4.32322 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (44,21,0) , diffuse = 4.22583 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (46,26,0) , diffuse = 4.12845 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (47,31,0) , diffuse = 4.03106 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (48,37,0) , diffuse = 3.93367 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (50,42,0) , diffuse = 3.83628 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (51,47,0) , diffuse = 3.7389 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (254,254,0) , diffuse = 1.00394 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_15 = pgl.Material("Color_15" , ambient = (0,0,255) , diffuse = 0.627451 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (157,158,205) , diffuse = 0 , specular = (0,0,0) , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_17 = pgl.Material("Color_17" , ambient = (97,0,83) , diffuse = 1.64948 , )
	Color_17.name = "Color_17"
	context.turtle.setMaterial(17,Color_17)
	Color_18 = pgl.Material("Color_18" , ambient = (0,143,126) , diffuse = 1.46154 , )
	Color_18.name = "Color_18"
	context.turtle.setMaterial(18,Color_18)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 26.6667 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (0,91,0) , diffuse = 2.8022 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (128,193,96) , diffuse = 0 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	Color_23 = pgl.Material("Color_23" , ambient = (74,35,0) , )
	Color_23.name = "Color_23"
	context.turtle.setMaterial(23,Color_23)
	context.options.setSelection('Warning with sharp module',0)
	context.options.setSelection('Selection Always Required',1)
	scalars = [('DEGRADATION', 'Bool', True), ('DIFFUSION', 'Bool', True), ('ACTIVATION', 'Bool', True), ('auxin', 'Bool', True), ('sugar', 'Integer', 2, 0, 2)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
__copyright__ = 'open-source GPL'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'F. Boudon, C. Godin'
