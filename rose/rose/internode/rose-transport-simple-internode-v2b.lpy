from copy import deepcopy
from numpy import arange

def plotCurve(data, xextend = None, yextend = None, pos = (0.1,-0.9), dim = (0.8,0.8), xtick = None, ytick = None ):
  if LPY_VERSION_MAJOR < 2 or (LPY_VERSION_MAJOR == 2 and LPY_VERSION_MINOR < 4):
    import warnings
    warnings.warn("Your version of lpy do not allow 2D plot")
    return
  from math import ceil, floor, log
  from openalea.plantgl.all import Polyline2D
  if type(data) == tuple:
    data = zip(data[0],data[1])
  if len(data) > 1:
    if xextend:
      minx, maxx = xextend
    else :
      minx = floor(min([x for x,y in data]))
      maxx = ceil(max([x for x,y in data]))
    if yextend:
      miny, maxy = yextend
    else :
      miny = floor(min([y for x,y in data]))
      maxy = ceil(max([y for x,y in data]))
    xext = maxx - minx
    yext = maxy - miny
    x2Dlength, y2Dlength = dim
    projx = lambda x: (x2Dlength*(x-minx)/xext)
    projy = lambda y: (y2Dlength*(y-miny)/yext)
    if xtick is None:
      nbdigit = round(log(xext,10))
      xtick = 10**(nbdigit-1)
    if ytick is None:
      nbdigit = round(log(yext,10))
      ytick = 10**(nbdigit-1)
    data = [(projx(x),projy(y)) for x,y in data]
    ticklength = 0.02
    
    nproduce [ @2D SetColor(255,0,0) @M(pos[0],pos[1]) @R @g(Polyline2D(data,width=2))
    if miny <= 0 <= maxy:
      nproduce SetColor(0,255,0) @g(Polyline2D([(projx(minx),projy(0)),(projx(maxx),projy(0))]))
      cxtick = ((minx // xtick) * xtick)
      if cxtick < minx : cxtick += xtick
      while cxtick <= maxx:
        if cxtick != 0:
          nproduce @g(Polyline2D([(projx(cxtick),projy(0)-ticklength),(projx(cxtick),projy(0)+ticklength)]))
        cxtick += xtick
    if minx <= 0 <= maxx:
      nproduce SetColor(0,0,255) @g(Polyline2D([(projx(0),projy(miny)),(projx(0),projy(maxy))]))
      cytick = ((miny // ytick)*ytick)
      if cytick < miny : cytick += ytick
      while cytick <= maxy:
        if cytick != 0:
          nproduce @g(Polyline2D([(projx(0)-ticklength,projy(cytick)),(projx(0)+ticklength,projy(cytick))]))
        cytick += ytick
    nproduce ]



nbEntity = 6
nbLatEntity = 3

min_level = 2.5
max_level = 10

innate_polarity = True
ACTIVATION = False
with_auxin_max_level = True

medium_auxin_level= 9
initial_auxin_level = 10
initial_lateral_auxin_level = 10

# for lateral inhibition
#active_transport_coef = 0.1 # T
#diffusion_coef = 0.05 # D

active_transport_coef = 0.5 # T
diffusion_coef = 0.02 # D

#apical_bud_auxin_synth_coef = 10
lateral_bud_auxin_synth_coef = 10.0  # for lapex
residual_auxin_synth_coef = 0.0 # \rho (c_i)

# auxin_synth_coef = 0.5 # \rho (c_i)
auxin_degrad_coef = 0.005 # \delta_a (a)

pin_degrad_coeff = 7.5# 1 # \delta_p (a) 
pin_synth_coeff = 0.15 
lateral_bud_init_time = 0

pin_init = 0.5

# parameter of the flux feedback function
h_coef = 10 # 7.5 # rho_i->j in the paper
K = 0.5#1.3
# non linear exponent of the flux feedback function
n = 3

ramif_threshold = 3

# pin competition parameter
pin_wall_coeff = 1 # k^+
wall_pin_coeff = 1. # k^-


def activation_flux_th(sugar) :
   return 2

max_pin = 5
dt = 0.05
lwidth = 0.02

def h(flux) :
  if flux > 0.:  return 0.

  fluxn = abs(flux) ** n
  return h_coef * (fluxn / (K**n + fluxn))

#def g(auxin):
#  g_coef = 1.
#  return g_coef * auxin

def txt(val):
    return str(round(val,2))[:5]

def fluxij(ci,cj,pinij,pinji):
    return active_transport_coef * (pinji *cj - pinij *ci) +  diffusion_coef * (cj-ci)

def dfluxij(fluxij,ci,cj,pinij,pinji):
  if fluxij <= 0.:
     return active_transport_coef * ci * h(fluxij) - pin_degrad_coeff * (abs(fluxij) ** n) + (pin_degrad_coeff * diffusion_coef + pin_synth_coeff*active_transport_coef)*(ci - cj)
  else:
     return - pin_degrad_coeff * fluxij + (pin_degrad_coeff * diffusion_coef + pin_synth_coeff*active_transport_coef)*(ci - cj)

monitorci, monitorcj, monitorpinij, monitorpji = None, None, None, None


class OrganParameter(ParameterSet):
  def __init__(self, auxin, sugar, order = 0, first = False, auxin_synth_coef= residual_auxin_synth_coef, **kwd):
#    """ State variable of a compartment.
#    
#    Parameters
#    ==========
#      - auxin : auxin concentration
#      - sugar : sugar concentration
#      - pin: PIN concentration in the organ not affected to the membranes
#      - pin_up = 0, # PIN surfacic concentration on upward membrane
#      - pin_down =0, # PIN surfacic concentration on downard membrane
#      pin_lat=0 # PIN surfacic concentration on lateral membrane
#      flux_up = 0 # flux coming from upward membrane (positive if entering the cell)
#      flux_down =0, # flux coming from downard membrane
#      flux_lat=0 # flux coming from lateral membrane
#    """
#    
    pin=kwd.get('pin',0) # PIN concentration in the organ not affected to the membranes
    pin_up = kwd.get('pin_up',0) # PIN surfacic concentration on upward membrane
    pin_down =kwd.get('pin_down',0) # PIN surfacic concentration on downard membrane
    pin_lat=kwd.get('pin_lat',0) # PIN surfacic concentration on lateral membrane
    flux_up = kwd.get('flux_up',0) # flux coming from upward membrane (positive if entering the cell)
    flux_down =kwd.get('flux_down',0) # flux coming from downard membrane
    flux_lat=kwd.get('flux_lat',0) # flux coming from lateral membrane
    
    ParameterSet.__init__(self, auxin=auxin, sugar=sugar, pin=pin, pin_up=pin_up, 
                          pin_down=pin_down, pin_lat=pin_lat,flux_up=flux_up, 
                          flux_down=flux_down, flux_lat=flux_lat,first=first,order=order,
                          auxin_synth_coef = auxin_synth_coef)
  def has_pin(self): return True

class ApexParameter(OrganParameter):
  def __init__(self, auxin, sugar, nbentity, time = 0, order = 0, active = False, auxin_synth_coef = residual_auxin_synth_coef, **kwd):
    OrganParameter.__init__(self, auxin, sugar, order, False, auxin_synth_coef, **kwd)
    self.time = time
    self.nbentity = nbentity
    self.active = active

class MediumParameter(OrganParameter):
  def __init__(self, auxin, sugar, first = False, auxin_synth_coef = residual_auxin_synth_coef, **kwd):
    OrganParameter.__init__(self, auxin, sugar, 0, first, auxin_synth_coef, **kwd)
  def has_pin(self): return True

def process_transport(p, pu = None, pd = None, pl = None, verbose = False):
  if not pl is None: 
    if len(pl) == 0: pl = None
    else: pl = pl[0]
  
  a = p.auxin
  fu, fd, fl  = p.flux_up, p.flux_down, p.flux_lat
  pin, pinu, pind, pinl = p.pin, p.pin_up , p.pin_down, p.pin_lat
  
  if pu: au =  pu.auxin
  if pd: ad =  pd.auxin
  if pl: al = pl.auxin
    
  p = deepcopy(p)
  
  # fluxs are counted as positive when they get into p
  net_flux = 0
  if pu:
    if verbose: print '*', active_transport_coef, pu.pin_down, p.pin_up, au, a, diffusion_coef
    p.flux_up = fluxij(a,au,p.pin_up,pu.pin_down)
    net_flux += p.flux_up 
  
  if pd:
    if pd.order < p.order:   pdpin = pd.pin_lat
    else:                    pdpin = pd.pin_up
    p.flux_down = fluxij(a,ad,p.pin_down,pdpin)
    net_flux +=  p.flux_down

  if pl:
    p.flux_lat = fluxij(a,al,p.pin_lat,pl.pin_down)                
    net_flux += p.flux_lat
  
  if verbose : print p.flux_up, p.flux_down, p.flux_lat
  
  # rate of change of auxin
  ra = 0
  
  # auxin synthesis
  auxin_synth_coef = p.auxin_synth_coef
  if not with_auxin_max_level:
     ra = auxin_synth_coef 
  else:
      ra = auxin_synth_coef * (max_level - p.auxin)# auxin synthesis
  
  ra += - auxin_degrad_coef * a # auxin degradation
  ra += net_flux # sum phi_ji sij / vi
  
  p.auxin += ra*dt 
  #assert 0. <= p.auxin <= 10. 
  # dPiu/dt, dPid/dt => rpinu, rpind
  hu = h(fu)
  hd = h(fd)
  hl = h(fl)
  
  if p.has_pin():
      net_rpin = 0
      if pu:
        rpinu = hu + pin_synth_coeff - pin_degrad_coeff*p.pin_up 
        if innate_polarity:
          rpinu = pin_synth_coeff - pin_degrad_coeff*p.pin_up
        p.pin_up += rpinu*dt
        net_rpin += rpinu
      
      if pd:
        if verbose == 2 : print '-', p.pin_down, 
        rpind = hd + pin_synth_coeff - pin_degrad_coeff*p.pin_down 
        p.pin_down += rpind*dt
        if verbose == 2 : print p.pin_down
        net_rpin += rpind
        
      if pl:
        rpinl = hl + pin_synth_coeff - pin_degrad_coeff*p.pin_lat
        if innate_polarity:
          rpinl = pin_synth_coeff - pin_degrad_coeff*p.pin_lat
        p.pin_lat += rpinl*dt
        net_rpin += rpinl
    
    #rpin = g(a) - pin_degrad_coeff*pin - net_rpin
    #p.pin += rpin*dt
  
  return p

initial_view= 0

module Apex(p) , I(p), Root(p), Medium(p), LApex(p) , LF(t)
Axiom: 
  nproduce _(2) Medium (MediumParameter(medium_auxin_level,0,first=True)) I(OrganParameter(initial_auxin_level,0,pin_down=pin_init)) [ 
  if lateral_bud_init_time > 0:  LF(0) 
  else : nproduce LApex(ApexParameter(initial_lateral_auxin_level, 0, nbEntity,0,1, active = False, auxin_synth_coef = lateral_bud_auxin_synth_coef))
  nproduce ] Medium(MediumParameter(medium_auxin_level,0,pin_down=pin_init))



derivation length: 10000
ignore: +-
production:

LF(t):
   if t < lateral_bud_init_time:
      produce LF(t+1)
   else:
     produce LApex(ApexParameter(initial_lateral_auxin_level, 0, nbEntity,0,1, active = False, auxin_synth_coef = lateral_bud_auxin_synth_coef))

Medium(pd) < I(p) > [  LApex(pl) ]  Medium(pu) :
  assert p.auxin_synth_coef == 0
  p = process_transport(p, pu, pd, [pl],verbose=False)
  produce I(p)

I(pd) < LApex(p) :
  # print p.auxin, pd.auxin, p.flux_down, p.pin_down
  p = process_transport(p,None, pd, None)
  if not p.active:
    if -p.flux_down > activation_flux_th(p.sugar) and ACTIVATION:
      p.active = True
  p.time += 1
  produce LApex(p)


Medium(pd) < I(p) >  Medium(pu) :
  p = process_transport(p, pu, pd, None)
  produce I(p)


Medium(p) >  I(pu): # The root compartment
  p = process_transport(p,pu, None, None)
  p.auxin = medium_auxin_level
  produce Medium(p)

I(pd) < Medium(p) : # The root compartment
  p = process_transport(p,None, pd, None) #, verbose = 2)
  p.auxin = medium_auxin_level
  produce Medium(p)



interpretation:
maximum depth: 4


I(p) :
    draw_internode(p)

Root(p) :
   draw_internode(p)


Medium(p) :
   draw_internode(p)



I(pd) [  <   LApex(p) :
   nproduce | f(1.5) +(90) f(1.5)
   draw_internode(p)
   nproduce Flower(p)
   fluxvalues = arange(-1,5,0.1)
   dfvalues  = map(lambda f: dfluxij(f,p.auxin,pd.auxin,p.pin_down,pd.pin_lat),fluxvalues)
   plotCurve((fluxvalues,dfvalues))

Flower(p):
   col = 0
   if not p.active: col = 9
   elif p.nbentity <= 0 : col = 0
   produce ,(col) f(0.1 if  not p.active else 0.6) @O(0.3 if not p.active else 0.6)

Apex(p) :
  draw_internode(p)
  produce Flower(p)


##############

T --> ,(0) f(0.3) @O(0.6)
B(x,h) -->  _(lwidth) f(-lwidth/2) +(90) F((x+lwidth)/2.)@O -(90) F(h+lwidth) @O -(90)F(x+lwidth) @O -(90)F(h+lwidth) @O -(90)F((x+lwidth)/2.)-(90)f(h+lwidth/2)


G(l) --> K(l,l)
K(l,h) --> f(h/2.){+(90)f(l/2.).+(90)f(h).+(90)f(l).+(90)f(h).}

endlsystem

def draw_internode(p):
   pinupr = 0.5 * p.pin_up /max_pin
   pindownr = 0.5 * p.pin_down /max_pin
   pinlatr = 0.5 * p.pin_lat /max_pin
   rfd = abs(p.flux_down)*0.02 +0.01
   rfu = abs(p.flux_up)*0.02 +0.01
   rfl = abs(p.flux_lat)*0.02 +0.01
   isapex = isinstance(p,ApexParameter)
   ismedium = isinstance(p,MediumParameter)
   tl = 3
   nproduce  [
   if not p.first:
     tl = 2.5
     nproduce ,(20 if p.flux_down > 0 else 21) _(rfd) F(0.5) 
     #nproduce [,(20 if p.flux_down < activation_flux_th(p.sugar) else 0)f(-0.8)-(90)f(1)^(90)f(1)Label('%.2f'%-p.flux_down)]
   nproduce  [,(1) f(pindownr/2) K(2,pindownr)] 
   nproduce [,(1)-(90)f(1+pinlatr/2)+(90)f(1+(pinupr+pindownr)/2)K(pinlatr,2+pinupr+pindownr)] # lateral pin box   
   nproduce [-(90)f(pinlatr/2)+(90),(21 if isapex else 20)B(2+pinlatr,2+pinupr+pindownr)] f(2+pinupr+pindownr) # black box
   nproduce [ ,(1) | f(pinupr/2) K(2,pinupr) ]  # up pin box
   if not ismedium or p.first:
     nproduce   ,(20 if p.flux_up > 0 else 21) _(rfu) F(0.5) 
   nproduce ] f(pindownr + (1.5 if not p.first else 1))
   if abs(p.flux_lat) > 1e-3 :
     nproduce [-(90) f(1+pinlatr),(20 if p.flux_lat > 0 else 21) _(rfl) F(0.5)
     if p.flux_lat < 0:
       nproduce  [,(10)|f(0.2)|_(rfl+0.2)F(0.4,rfl)]
     elif p.flux_lat > 0:
       nproduce  [,(10)|f(0.2)|_(rfl)F(0.4,rfl+0.2)]
     nproduce ]
     
   if ismedium :
     bgcol = 16
   elif isapex:
     bgcol = 22
   else: 
     bgcol = 6
    
   nproduce  [,(bgcol)G(2)]
   nproduce  [^(90)f(0.01)&(90),(15)G(2.*p.auxin/(max_level*2))]
   
   nproduce  f(1.5+pinupr)
   
   if not isinstance(p,MediumParameter) or p.first:
     # draw top arrow
     if p.flux_up < 0:
       nproduce  [,(10)|f(0.2)|_(rfu+0.2)F(0.4,rfu)]
     elif p.flux_up > 0:
       nproduce  [,(10)|f(0.2)|_(rfu)F(0.4,rfu+0.2)]
     
   #   nproduce [,(20)-(90)f(0.5)Label('%.2f'%p.flux_up)]
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (39,0,0) , diffuse = 4.61538 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_1 = pgl.Material("Color_1" , ambient = (40,5,0) , diffuse = 4.518 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (41,10,0) , diffuse = 4.42061 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (43,15,0) , diffuse = 4.32322 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (44,21,0) , diffuse = 4.22583 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (46,26,0) , diffuse = 4.12845 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (47,31,0) , diffuse = 4.03106 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (48,37,0) , diffuse = 3.93367 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (50,42,0) , diffuse = 3.83628 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (51,47,0) , diffuse = 3.7389 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (53,53,0) , diffuse = 3.64151 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_15 = pgl.Material("Color_15" , ambient = (0,0,255) , diffuse = 0.627451 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (157,158,205) , diffuse = 0 , specular = (0,0,0) , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 26.6667 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (0,95,0) , diffuse = 0 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (128,193,96) , diffuse = 0 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	context.options.setSelection('Warning with sharp module',0)
	context.options.setSelection('Selection Always Required',1)
	scalars = [('PIN_COMPETITION', 'Bool', False)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] is "Category" : context[s[0]] = s[2]
__copyright__ = 'open-source GPL'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'F. Boudon, C. Godin'
