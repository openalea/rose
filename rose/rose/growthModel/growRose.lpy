from numpy import *

########### TIME of the model and the crop (A externaliser) ###############
# initialization:a ne pas externaliser
# ddC=Thermal Time of the crop; ATTENTION: a etablir bien avant tous les debourrements
ddC=0.
step=0
# Steps
timestep=1.
Ddd=10.# Timestep of the model in degree days
nsteps=80 # number of model steps


########### Model paramaters (A laisser dans le code) #############
# Curvature parameters for Weibull extension functions: ici exprimes en rang relatif
cUnit="rang relatif"
nrel=[0.,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.0]
cfolArel=[1.62,1.65,1.68,1.71,1.75,1.79,1.84,1.92,2.07,2.29,2.60,2.97,3.41,3.89,4.38,4.87,5.32,5.73,6.11,6.48] # du coup comment faire quand on a un nombre de phyto variable ???
cENrel=[1.96,2.02,2.07,2.13,2.22,2.34,2.49,2.69,2.97,3.38,3.95,4.63,5.40,6.22,7.03,7.78,8.36,8.71,8.91,9.06,6.69] # for internodes and the peduncle
Fola2Rachis=(0.9,0.1) # coefficients -slope and intercept- of the linear relationship between leaflet A length and rachis length; il faut encore trouver la bonne relation 


########### Input variables (A externaliser)#####################################
# At the canopy scale
nplants=2
# At the plant scale
ddEM=[60.,60.] ## emergence date of the plants; il faut que 10 (Ddd)-ddEM soit antérieur à la date d'apparition des premieres feuilles !
nphy=[16,10] # phytomers number plus one corresponding to the peduncle (bearing a virtual leaf)
Stages=[(460.,570.,760.,860.),(460.,570.,760.,860.)] #stages of floral development: BFV,CPV,FO,FF
DmaxFlo=50.
DminFlo=1.
# At the leaf scale
ApF=[(31.9187169, 33.8468667, 35.7750165, 37.703166299999999, 39.631316099999999, 41.559465889999998, 50.139252679999998, 92.497518459999995, 134.85578430000001, 177.21404999999999, 219.57231580000001, 261.93058159999998, 304.28884740000001, 346.64711319999998, 389.005379, 431.36364479999997),(0.0, 0.0, 0.0, 0.0, 0.0, 4.1733644779999999, 47.83551585, 91.497667210000003, 135.15981859999999, 178.82196999999999)]
LmaxfolA=[(0.0, 0.0, 0.0, 12.21919274, 36.144714780000001, 51.781817510000003, 47.161323799999998, 47.878200380000003, 52.121564970000001, 60.452758350000003, 60.187551470000002, 63.600457980000002, 65.458066669999994, 58.095660649999999, 50.530889569999999, 0.0), (0.0, 0.0, 0.0, 0.0, 31.60014601, 54.400271259999997, 61.134985720000003, 62.218311419999999, 76.495903870000006, 0.0)]
LmaxEN=[(1.0, 2.0, 7.0, 7.0, 10.276169149999999, 12.1021774, 14.63757296, 18.333811709999999, 19.750325029999999, 29.59766329, 31.381721429999999, 29.201288819999998, 26.937320629999999, 22.197394039999999, 20.0, 43.360002880000003),(1.0, 1.0, 3.0, 11.270428839999999, 12.52623015, 19.476321389999999, 22.281030380000001, 36.93544971, 22.59415808, 62.787773350000002)]

# ATTENTION: Modifier la suite:
RmaxRachis=0.5
nfol=5 ## pour l'instant ne sert pas
RmaxEN=3


######### Functions used for the calculations ###################

# a et b sont des tuple de 2 coord x et y
def linearInterpol(x,a,b):
  return a[1]+(b[1]-a[1])/(b[0]-a[0])*(x-a[0])

# Calcul du c relatif:
# attention: verifier qu'on a pas de probleme quand on est au dessus de 0.95
# je mets 0 pour cfolA quand n=N: de toute facon, cette valeur n'est pas utilisee
def c(n,N):
  if cUnit=="rang absolu":
    cest=(cfolAabs[n-1],cENabs[n-1])
  elif cUnit=="rang inverse":
    cest=(cfolAinv[n-1],cENinv[n-1])
  else:
    if n==N:
      cest=(0,cENrel[len(cENrel)-1])
    else:
      rrel=float(n-1)/float(N-1)
      irrel=-1
      i=-1
      while irrel==-1:
        i=i+1
        if rrel==nrel[i]:
          irrel=i
          cest=(cfolArel[irrel],cENrel[irrel])
        else:
          if rrel<nrel[i]:
            irrel=(i-1,i)
            cest=(linearInterpol(rrel,(nrel[irrel[0]],cfolArel[irrel[0]]),(nrel[irrel[1]],cfolArel[irrel[1]])),linearInterpol(rrel,(nrel[irrel[0]],cENrel[irrel[0]]),(nrel[irrel[1]],cENrel[irrel[1]])))
  return cest


# Calculation of the rachis length as a function of the terminal leaflet length
def Lrachis(lfola,fola2rachis):
  return lfola*fola2rachis[0]+fola2rachis[1]

# Calculation of the tmax parameters of the extension function from the thermal time of leaf appearance
def tmaxFolAFUN(apf):
  tmax=1.37*apf+71.62
  return tmax
def tmaxENFUN(apf):
  tmax=1.37*apf+83.88
  return tmax

# Weibull extension function for leaves and internodes, with as parameters, the final length of the organ, c and tmax parameters, and the thermal time since plant emergence (careful:weibull does not work for negative values)
def extend(lengthMax,c,tmax,dd):
  L=lengthMax*(1-exp(-(c-1)/c*(dd/tmax)**c))  
  if L>=lengthMax*0.98:
    L=lengthMax
  return L

# Flower opening
def extendFlower(stage,dmax,dd):
  if dd>=stage[3]:
    D=dmax
  else:
    slope=(dmax-DminFlo)/(stage[3]-stage[0])
    intercept=dmax-slope*stage[3]
    D=slope*dd+intercept
  return D

# Calculation of the number of leaves appearing in a time step defined by its lower and upper limits
def NbApF(low,up,apfplant):
  nb=0
  for i in apfplant:
    if i>=low and i<up:
       nb=nb+1
  return nb



######### Le L-system #############################

module canopy(ddcrop):scale=1
module plant(x,y,z):scale=2
module A(plantnum,n,N,dd0,ddcrop):scale=3
module leaf(plantnum,LfolA,Lrachis,dd0,n):scale=3
module EN(plantnum,L,dd0,n):scale=3
module Flower(plantnum,D,dd0,n):scale=3

Axiom: canopy(0.)


# bizarre: sous visualea, on ne passe pas dans le end

def End():
  print "end"
  print(" ")

def StartEach():
  global ddC
  global step
  step=step+timestep
  ddC=ddC+Ddd
  #print "starteach"
  
def EndEach():
  #print "endeach"
  print("   ")

derivation length: nsteps
production:


canopy(ddcrop):
  #print "canopy"
  #print ddcrop
  if nplants==1:
    produce plant(0,0,0)A(1,0,nphy[0],ddEM[0],ddcrop)
  else:
    i=1
    j=1
    for p in range(nplants):
      x=150*i
      y=150*j
      z=0
      if (p+1)%6==0:
        j=j+1
        i=1
      else:
        i=i+1
      nproduce plant(x,y,z)A(p+1,0,nphy[p],ddEM[p],ddcrop)


# theoriquement faire apparaître les 8 feuilles et EN deja presents dans le bourgeon
# la condition dd<0 est necessaire car Weibull donne une fonction décroissante pour les valeurs negatives
A(plantnum,n,N,dd0,ddcrop):
  ddcrop=ddC
  dd=ddcrop-dd0
  print 'temps thermique:', ddcrop
  nF2do=N-1-n
  #print nF2do
  if nF2do>0:
    #print "ok"
    if dd<0 and dd>=ApF[plantnum-1][n] and dd<ApF[plantnum-1][n]+Ddd:
      nbAp=NbApF(ApF[plantnum-1][n],(ApF[plantnum-1][n]+Ddd),ApF[plantnum-1])
      #print "ok1"
      for i in range(nbAp-1):
        n=n+1
        nproduce EN(plantnum,0.05,dd0,n)[leaf(plantnum,0.05,0.05,dd0,n)]
      n=n+1
      produce EN(plantnum,0.05,dd0,n)[leaf(plantnum,0.05,0.05,dd0,n)]A(plantnum,n,N,dd0,ddcrop)
    elif dd>=0 and dd>=ApF[plantnum-1][n] and dd<ApF[plantnum-1][n]+Ddd:
      nbAp=NbApF(ApF[plantnum-1][n],ApF[plantnum-1][n]+Ddd,ApF[plantnum-1])
      #print "ok2"
      for i in range(nbAp-1):
        n=n+1
        tmaxEN=tmaxENFUN(ApF[plantnum-1][n-1])
        tmaxFolA=tmaxFolAFUN(ApF[plantnum-1][n-1])
        len=extend(LmaxEN[plantnum-1][n-1],c(n,N)[1],tmaxEN,dd)
        lengthfola=extend(LmaxfolA[plantnum-1][n-1],c(n,N)[0],tmaxFolA,dd)
        lrachis=lengthfola*Fola2Rachis[0]+Fola2Rachis[1]
        nproduce EN(plantnum,len,dd0,n)[leaf(plantnum,lengthfola,lrachis,dd0,n)]
      tmaxEN=tmaxENFUN(ApF[plantnum-1][n-1])
      tmaxFolA=tmaxFolAFUN(ApF[plantnum-1][n-1])
      len=extend(LmaxEN[plantnum-1][n-1],c(n,N)[1],tmaxEN,dd)
      lengthfola=extend(LmaxfolA[plantnum-1][n-1],c(n,N)[0],tmaxFolA,dd)
      lrachis=lengthfola*Fola2Rachis[0]+Fola2Rachis[1]
      n=n+1
      produce EN(plantnum,len,dd0,n)[leaf(plantnum,lengthfola,lrachis,dd0,n)]A(plantnum,n,N,dd0,ddcrop)
    else:
      #print "ok3"
      produce A(plantnum,n,N,dd0,ddcrop)
  elif n==N-1:
    if dd>=ApF[plantnum-1][n] and dd<ApF[plantnum-1][n]+Ddd:
      produce EN(plantnum,0.05,dd0,N)A(plantnum,N,N,dd0,ddcrop)
    else:
      produce A(plantnum,n,N,dd0,ddcrop)
  else:
    produce Flower(plantnum,DminFlo,dd0,N)
    

leaf(plantnum,LfolA,Lrachis,dd0,n):
  dd=ddC-dd0
  if dd>=dd0:
    tmax=tmaxFolAFUN(ApF[plantnum-1][n-1])
    lengthfola=extend(LmaxfolA[plantnum-1][n-1],c(n,nphy[plantnum-1])[0],tmax,dd)
    lrachis=lengthfola*Fola2Rachis[0]+Fola2Rachis[1]
    produce leaf(plantnum,lengthfola,lrachis,dd0,n)
  else:
    produce leaf(plantnum,LfolA,Lrachis,dd0,n)

# l'entre-noeud prend l'age de la feuille
EN(plantnum,L,dd0,n):
  dd=ddC-dd0
  if dd>=dd0:
    tmax=tmaxENFUN(ApF[plantnum-1][n-1])
    produce EN(plantnum,extend(LmaxEN[plantnum-1][n-1],c(n,nphy[plantnum-1])[1],tmax,dd),dd0,n)
  else:
    produce EN(plantnum,L,dd0,n)

Flower(plantnum,D,dd0,n):
  dd=ddC-dd0
  apFN=ApF[plantnum-1][nphy[plantnum-1]-1]
  produce Flower(plantnum,extendFlower(Stages[plantnum-1],DmaxFlo,dd),dd0,n)


################### GEOMETRIC INTERPRETATION (A externaliser) ############################

interpretation:
plant(x,y,z)-->@M(x,y,z)
# attention: il tourne les plantes les unes par rapport aux autres
# pour l'instant, toutes les folioles d'une feuille ont la même longueur que la foliole A et la forme des folioles est celle prédéfinie dans Lpy
# je n'ai rien fait d'automatique pour la visualisation en fonction du nombre de folioles
leaf(plantnum,LfolA,Lrachis,dd0,n)-->;(2)+(70)/(90)_(1)F(2*Lrachis/(nfol+1))+(90)~l(LfolA)-(180)~l(LfolA)+(90)_(1)F(2*Lrachis/(nfol+1))+(90)~l(LfolA)-(180)~l(LfolA)+(90)_(1)F(2*Lrachis/(nfol+1))~l(LfolA)
EN(plantnum,L,dd0,n)-->;(1)/(180)_(2)F(L)
Flower(plantnum,D,dd0,n)-->;(3)@O(D)
A(plantnum,n,N,dd0,ddcrop)-->*
canopy(ddcrop)-->*

endlsystem