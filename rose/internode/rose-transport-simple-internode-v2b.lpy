from copy import deepcopy
from numpy import arange


def plotCurve(curvedata, pointdata = None, xextend = None, yextend = None, pos = (0.1,-0.3), dim = (0.8,0.8), xtick = None, ytick = None ):
  if LPY_VERSION_MAJOR < 2 or (LPY_VERSION_MAJOR == 2 and LPY_VERSION_MINOR < 4):
    import warnings
    warnings.warn("Your version of lpy do not allow 2D plot")
    return
  from math import ceil, floor, log
  from openalea.plantgl.all import Polyline2D
  if type(curvedata) == tuple:
    curvedata = zip(curvedata[0],curvedata[1])
  if type(pointdata) == tuple:
    pointdata = zip(pointdata[0],pointdata[1])
  data = list(curvedata)
  if not pointdata is None:
    data += pointdata
  if len(data) > 1:
    if xextend:
      minx, maxx = xextend
    else :
      minx = floor(min([x for x,y in data]))
      maxx = ceil(max([x for x,y in data]))
    if yextend:
      miny, maxy = yextend
    else :
      miny = floor(min([y for x,y in data]))
      maxy = ceil(max([y for x,y in data]))
    xext = maxx - minx
    yext = maxy - miny
    x2Dlength, y2Dlength = dim
    projx = lambda x: (x2Dlength*(x-minx)/xext)
    projy = lambda y: (y2Dlength*(y-miny)/yext)
    if xtick is None:
      nbdigit = round(log(xext,10))
      xtick = 10**(nbdigit-1)
    if ytick is None:
      nbdigit = round(log(yext,10))
      ytick = 10**(nbdigit-1)
    curvedata = [(projx(x),projy(y)) for x,y in curvedata]
    ticklength = 0.02
    
    nproduce [ @2D SetColor(255,0,0) @M(pos[0],pos[1]) @R 
    if not curvedata is None:
      nproduce @g(Polyline2D(curvedata,width=2))
    if not pointdata is None:
      nproduce SetColor(255,0,255)
      for x,y in pointdata:
        nproduce [ @M(pos[0]+projx(x),pos[1]+projy(y)) @O(0.03)]
    if miny <= 0 <= maxy:
      nproduce SetColor(0,255,0) @g(Polyline2D([(projx(minx),projy(0)),(projx(maxx),projy(0))]))
      cxtick = ((minx // xtick) * xtick)
      if cxtick < minx : cxtick += xtick
      while cxtick <= maxx:
        if cxtick != 0:
          nproduce @g(Polyline2D([(projx(cxtick),projy(0)-ticklength),(projx(cxtick),projy(0)+ticklength)]))
        cxtick += xtick
    if minx <= 0 <= maxx:
      nproduce SetColor(0,0,255) @g(Polyline2D([(projx(0),projy(miny)),(projx(0),projy(maxy))]))
      cytick = ((miny // ytick)*ytick)
      if cytick < miny : cytick += ytick
      while cytick <= maxy:
        if cytick != 0:
          nproduce @g(Polyline2D([(projx(0)-ticklength,projy(cytick)),(projx(0)+ticklength,projy(cytick))]))
        cytick += ytick
    nproduce ]




innate_polarity = True
ACTIVATION = False
with_auxin_max_level = True

initial_internode_auxin_level = 10 # cj
initial_bud_auxin_level = 5      # ci
initial_top_medium_auxin_level= 10
initial_root_medium_auxin_level= 3

active_transport_coef = 0.5 # T
diffusion_coef = 0.1 # D

apical_bud_auxin_synth_coef = 10
lateral_bud_auxin_synth_coef = 10.0  # for lapex
residual_auxin_synth_coef = 0.5 # \rho (c_i)

#auxin_synth_coef = 10.0 # \rho (c_i)
auxin_target_concentration = 10.0
delayed_lateral_bud_target_concentration = 10
delayed_apex_target_concentration = 5
# bud_auxin_target_concentration = 10.0

# axin degradation coefficient
default_auxin_degrad_coef = 0.1 # v (a)
root_auxin_degrad_coef = 1.0 # v (a)

pin_synth_coeff = 0.0 # rho_0
pin_degrad_coeff = 10  # \mu

pin_init = 0.5

# parameter of the flux feedback function
h_coef = 7.5 # rho_i->j in the paper
# non linear exponent of the flux feedback function
n = 3
# hill saturation coef
K = 1.3

dt = 0.05

# Graphical parameters 
max_pin_value = 1
lwidth = 0.02



def h(flux) :
  if flux < 0.:  return 0.

  fluxn = abs(flux) ** n
  return h_coef * (fluxn / (K**n + fluxn))


def txt(val):
    return str(round(val,2))[:5]

def fluxij(ci,cj,pinij,pinji):
    return active_transport_coef * (pinij *ci - pinji *cj) +  diffusion_coef * (ci-cj)


def dfluxij(fluxij, ci, cj, efi, efj, verbose = False):
  selfenhancingterm = active_transport_coef * ci * h(fluxij)
  
  degradationterm = - pin_degrad_coeff * (fluxij)
  
  diffusionterm1 = (pin_synth_coeff*active_transport_coef)*(ci*efi - cj*efj)
  diffusionterm2 =  (pin_degrad_coeff * diffusion_coef *(ci - cj)) 
  if verbose : print diffusionterm1, diffusionterm2
  diffusionterm = diffusionterm1 + diffusionterm2
  
  result = 0
  if fluxij > 0.:
     result =  selfenhancingterm 
  if DEGRADATION:
     result += degradationterm 
  if DIFFUSION:
     result += diffusionterm
  return result

flux_threshold = 10
def activation_flux_th(p):
  return p.flux_down > flux_threshold

monitorci, monitorcj, monitorpinij, monitorpji = None, None, None, None


class OrganParameter(ParameterSet):
  def __init__(self, **kwd):
#    """ State variable of a compartment.
#    
#    Parameters
#    ==========
#      - auxin : auxin concentration
#      - sugar : sugar concentration
#      - pin: PIN concentration in the organ not affected to the membranes
#      - pin_up = 0, # PIN surfacic concentration on upward membrane
#      - pin_down =0, # PIN surfacic concentration on downard membrane
#      pin_lat=0 # PIN surfacic concentration on lateral membrane
#      flux_up = 0 # flux coming from upward membrane (positive if entering the cell)
#      flux_down =0, # flux coming from downard membrane
#      flux_lat=0 # flux coming from lateral membrane
#    """
#    
    ParameterSet.__init__(self, **kwd)
    
    # auxin and sugar concentration
    self.setdefault(auxin=0, sugar=0)
    # topological situation
    self.setdefault(first = False, order = 0)
    # pin concentration
    # PIN surfacic concentration on the upward, downward and lateral membrane
    self.setdefault(pin_up=0, pin_down=0,  pin_lat=0)
    self.setdefault(pin_efficiency=1)
    # flux coming from the upward, downward and lateral membrane (negative if entering the cell)
    self.setdefault(flux_up=0, flux_down=0, flux_lat=0)
    # auxin coeficient
    self.setdefault(auxin_synth_coef  = residual_auxin_synth_coef, 
                    auxin_degrad_coef = default_auxin_degrad_coef,
                    auxin_target_concentration = self.auxin)

class ApexParameter(OrganParameter):
  def __init__(self, **kwd):
    OrganParameter.__init__(self, **kwd)
    self.setdefault(active=False)


initial_view= 0

def StartEach(lstring):
  if getIterationNb() == 60:
      lstring[4].p.auxin_target_concentration = delayed_lateral_bud_target_concentration
  elif getIterationNb() == 120:
      lstring[-2].p.auxin_target_concentration = delayed_apex_target_concentration

module Apex(p) , I(p), Root(p), Medium(p), LApex(p) , LF(t)
Axiom: 
  nproduce _(2) 
  nproduce Medium (OrganParameter(auxin=initial_root_medium_auxin_level, auxin_degrad_coef = root_auxin_degrad_coef, first=True, medium=True)) 
  nproduce I(OrganParameter(auxin=initial_internode_auxin_level,pin_down=pin_init)) 
  nproduce [ LApex(ApexParameter(auxin=initial_bud_auxin_level, auxin_synth_coef = lateral_bud_auxin_synth_coef)) ]
  nproduce Medium(OrganParameter(auxin=initial_top_medium_auxin_level,pin_down=pin_init,medium=True,auxin_synth_coef=apical_bud_auxin_synth_coef))
  nproduce E



def process_transport(p, pu = None, pd = None, pl = None, verbose = False):
  if not pl is None: 
    if len(pl) == 0: pl = None
    else: pl = pl[0]
  
  a = p.auxin
  fu, fd, fl  = p.flux_up, p.flux_down, p.flux_lat
  pinu, pind, pinl = p.pin_up , p.pin_down, p.pin_lat
  
  if pu: au =  pu.auxin
  if pd: ad =  pd.auxin
  if pl: al = pl.auxin
    
  p = deepcopy(p)
  
  # fluxs are counted negativelly when they get into p
  net_flux = 0
  if pu:
    p.flux_up = fluxij(a,au,p.pin_up*p.pin_efficiency,pu.pin_down*pu.pin_efficiency)
    net_flux += p.flux_up 
  
  if pd:
    if pd.order < p.order:   pdpin = pd.pin_lat
    else:                    pdpin = pd.pin_up
    
    p.flux_down = fluxij(a,ad,p.pin_down*p.pin_efficiency,pdpin*pd.pin_efficiency)
    net_flux +=  p.flux_down

  if pl:
    p.flux_lat = fluxij(a,al,p.pin_lat*p.pin_efficiency,pl.pin_down*pl.pin_efficiency)                
    net_flux += p.flux_lat
  
  if verbose : print p.flux_up, p.flux_down, p.flux_lat
  
  # rate of change of auxin
  ra = 0
  
  # auxin synthesis
  if not with_auxin_max_level:
      ra = p.auxin_synth_coef 
  else:
      ra = p.auxin_synth_coef * (p.auxin_target_concentration - a)# auxin synthesis
  
  ra += - p.auxin_degrad_coef * a # auxin degradation
  ra -= net_flux # sum phi_ji sij / vi
  
  p.auxin += ra*dt 
  #assert 0. <= p.auxin <= 10. 
  # dPiu/dt, dPid/dt => rpinu, rpind
  hu = h(fu)
  hd = h(fd)
  hl = h(fl)
  
  # pin concentration.
  net_rpin = 0
  if pu:
    rpinu = hu + pin_synth_coeff - pin_degrad_coeff*p.pin_up 
    if innate_polarity:
      rpinu = pin_synth_coeff - pin_degrad_coeff*p.pin_up
    p.pin_up += rpinu*dt
    net_rpin += rpinu
  
  if pd:
    rpind = hd + pin_synth_coeff - pin_degrad_coeff*p.pin_down 
    p.pin_down += rpind*dt
    net_rpin += rpind
    
  if pl:
    rpinl = hl + pin_synth_coeff - pin_degrad_coeff*p.pin_lat
    if innate_polarity:
      rpinl = pin_synth_coeff - pin_degrad_coeff*p.pin_lat
    p.pin_lat += rpinl*dt
    net_rpin += rpinl

#rpin = g(a) - pin_degrad_coeff*pin - net_rpin
    #p.pin += rpin*dt
  
  return p


derivation length: 500
ignore: +-
production:

Medium(pd) < I(p) > [  LApex(pl) ]  Medium(pu) :
  p = process_transport(p, pu, pd, [pl],verbose=False)
  produce I(p)

I(pd) < LApex(p) :
  # print p.auxin, pd.auxin, p.flux_down, p.pin_down
  p = process_transport(p,None, pd, None)
  if not p.active:
    if  activation_flux_th(p) and ACTIVATION:
      p.active = True
  produce LApex(p)


Medium(pd) < I(p) >  Medium(pu) :
  p = process_transport(p, pu, pd, None)
  produce I(p)


Medium(p) >  I(pu): # The root compartment
  p = process_transport(p,pu, None, None)
  p.auxin = initial_root_medium_auxin_level
  produce Medium(p)

I(pd) < Medium(p) : # The root compartment
  p = process_transport(p,None, pd, None) #, verbose = 2)
  #p.auxin = initial_top_medium_auxin_level
  produce Medium(p)



interpretation:
maximum depth: 4


I(p) :
    draw_internode(p)

Root(p) :
   draw_internode(p)


Medium(p) :
   draw_internode(p)



I(pd) [  <   LApex(p) :
   nproduce | f(1.5) +(90) f(1.5)
   draw_internode(p)
   nproduce Flower(p)
   mdfluxij = lambda f: dfluxij(f,p.auxin, pd.auxin, p.pin_efficiency, pd.pin_efficiency)
   
   fluxvalues = arange(-1,5,0.1)
   dfvalues  = map(mdfluxij,fluxvalues)
   # print p.flux_down,mdfluxij(p.flux_down)
   mdfluxij = lambda f: dfluxij(f,p.auxin, pd.auxin, p.pin_efficiency, pd.pin_efficiency)
   plotCurve((fluxvalues,dfvalues),[(p.flux_down, mdfluxij(p.flux_down))]) #,yextend=(-5,10))


Flower(p):
   col = 0
   if not p.active: col = 9
   elif p.nbentity <= 0 : col = 0
   produce ,(col) f(0.1 if  not p.active else 0.6) @O(0.3 if not p.active else 0.6)

Apex(p) :
  draw_internode(p)
  produce Flower(p)


##############

T --> ,(0) f(0.3) @O(0.6)
B(x,h) -->  _(lwidth) f(-lwidth/2) +(90) F((x+lwidth)/2.)@O -(90) F(h+lwidth) @O -(90)F(x+lwidth) @O -(90)F(h+lwidth) @O -(90)F((x+lwidth)/2.)-(90)f(h+lwidth/2)


G(l) --> K(l,l)
K(l,h) --> f(h/2.){+(90)f(l/2.).+(90)f(h).+(90)f(l).+(90)f(h).}

E --> @2D @M(0.9,0.9 )Label( str(getIterationNb()) )

endlsystem

def draw_internode(p):
   pinupr = 0.5 * p.pin_up /max_pin_value
   pindownr = 0.5 * p.pin_down /max_pin_value
   pinlatr = 0.5 * p.pin_lat /max_pin_value
   rfd = abs(p.flux_down)*0.02 +0.01
   rfu = abs(p.flux_up)*0.02 +0.01
   rfl = abs(p.flux_lat)*0.02 +0.01
   isapex = isinstance(p,ApexParameter)
   ismedium = p.hasattr('medium')
   tl = 3
   nproduce  [
   if not p.first:
     tl = 2.5
     nproduce ,(20 if p.flux_down < 0 else 21) _(rfd) F(0.5) 
     #nproduce [,(20 if p.flux_down < activation_flux_th(p.sugar) else 0)f(-0.8)-(90)f(1)^(90)f(1)Label('%.2f'%-p.flux_down)]
   nproduce [,(1) f(pindownr/2) K(2,pindownr)] 
   nproduce [,(1)-(90)f(1+pinlatr/2)+(90)f(1+(pinupr+pindownr)/2)K(pinlatr,2+pinupr+pindownr)] # lateral pin box   
   nproduce [-(90)f(pinlatr/2)+(90),(21 if isapex else 20)B(2+pinlatr,2+pinupr+pindownr)] f(2+pinupr+pindownr) # black box
   nproduce [ ,(1) | f(pinupr/2) K(2,pinupr) ]  # up pin box
   if not ismedium or p.first:
     nproduce   ,(20 if p.flux_up < 0 else 21) _(rfu) F(0.5) 
   nproduce ] f(pindownr + (1.5 if not p.first else 1))
   if abs(p.flux_lat) > 1e-3 :
     nproduce [-(90) f(1+pinlatr),(20 if p.flux_lat < 0 else 21) _(rfl) F(0.5)
     if p.flux_lat > 0:
       nproduce  [,(10)|f(0.2)|_(rfl+0.2)F(0.4,rfl)]
     elif p.flux_lat < 0:
       nproduce  [,(10)|f(0.2)|_(rfl)F(0.4,rfl+0.2)]
     nproduce ]
     
   if ismedium :
     bgcol = 16
   elif isapex:
     bgcol = 22
   else: 
     bgcol = 6
    
   nproduce  [,(bgcol)G(2)]
   nproduce  [^(90)f(0.01)&(90),(15)G(2.*p.auxin/(auxin_target_concentration*2))]
   
   nproduce  f(1.5+pinupr)
   
   if not ismedium or p.first:
     # draw top arrow
     if p.flux_up > 0:
       nproduce  [,(10)|f(0.2)|_(rfu+0.2)F(0.4,rfu)]
     elif p.flux_up < 0:
       nproduce  [,(10)|f(0.2)|_(rfu)F(0.4,rfu+0.2)]
     
   #   nproduce [,(20)-(90)f(0.5)Label('%.2f'%p.flux_up)]


###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (39,0,0) , diffuse = 4.61538 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_1 = pgl.Material("Color_1" , ambient = (40,5,0) , diffuse = 4.518 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (41,10,0) , diffuse = 4.42061 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (43,15,0) , diffuse = 4.32322 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (44,21,0) , diffuse = 4.22583 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (46,26,0) , diffuse = 4.12845 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (47,31,0) , diffuse = 4.03106 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (48,37,0) , diffuse = 3.93367 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (50,42,0) , diffuse = 3.83628 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (51,47,0) , diffuse = 3.7389 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (53,53,0) , diffuse = 3.64151 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_15 = pgl.Material("Color_15" , ambient = (0,0,255) , diffuse = 0.627451 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (157,158,205) , diffuse = 0 , specular = (0,0,0) , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 26.6667 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (0,95,0) , diffuse = 0 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (128,193,96) , diffuse = 0 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	context.options.setSelection('Warning with sharp module',0)
	context.options.setSelection('Selection Always Required',1)
	scalars = [('DEGRADATION', 'Bool', True), ('DIFFUSION', 'Bool', True), ('ACTIVATION', 'Bool', True)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
__copyright__ = 'open-source GPL'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'F. Boudon, C. Godin'
