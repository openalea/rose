from copy import deepcopy
from numpy import arange

def plotCurve(data, xextend = None, yextend = None, pos = (0.1,0.1), dim = (0.8,0.8), xtick = None, ytick = None ):
  if LPY_VERSION_MAJOR < 2 or (LPY_VERSION_MAJOR == 2 and LPY_VERSION_MINOR < 4):
    import warnings
    warnings.warn("Your version of lpy do not allow 2D plot")
    return
  from math import ceil, floor, log
  from openalea.plantgl.all import Polyline2D
  if type(data) == tuple:
    data = zip(data[0],data[1])
  if len(data) > 1:
    if xextend:
      minx, maxx = xextend
    else :
      minx = min([x for x,y in data])
      maxx = max([x for x,y in data])
    if yextend:
      miny, maxy = yextend
    else :
      miny = min([y for x,y in data])
      maxy = max([y for x,y in data])
    xext = maxx - minx 
    yext = maxy - miny
    if yext == 0: yext = xext
    if xtick is None:
      nbdigit = round(log(xext,10))
      xtick = 10**(nbdigit-1)
    if ytick is None:
      nbdigit = round(log(yext,10))
      ytick = 10**(nbdigit-1)
    x2Dlength, y2Dlength = dim
    projx = lambda x: (x2Dlength*(x-minx)/xext)
    projy = lambda y: (y2Dlength*(y-miny)/yext)
    data = [(projx(x),projy(y)) for x,y in data]
    ticklength = 0.02
    
    nproduce [ @2D SetColor(255,0,0) @M(pos[0],pos[1]) @R @g(Polyline2D(data,width=2))
    if miny <= 0 <= maxy:
      nproduce SetColor(0,255,0) @g(Polyline2D([(projx(minx),projy(0)),(projx(maxx),projy(0))]))
      cxtick = ((minx // xtick) * xtick)
      if cxtick < minx : cxtick += xtick
      while cxtick <= maxx:
        if cxtick != 0:
          nproduce @g(Polyline2D([(projx(cxtick),projy(0)-ticklength),(projx(cxtick),projy(0)+ticklength)]))
        cxtick += xtick
    if minx <= 0 <= maxx:
      nproduce SetColor(0,0,255) @g(Polyline2D([(projx(0),projy(miny)),(projx(0),projy(maxy))]))
      cytick = ((miny // ytick)*ytick)
      if cytick < miny : cytick += ytick
      while cytick <= maxy:
        if cytick != 0:
          nproduce @g(Polyline2D([(projx(0)-ticklength,projy(cytick)),(projx(0)+ticklength,projy(cytick))]))
        if cytick == (maxy-cytick):
          # print projx(0)+2*ticklength,projy(cytick), cytick
          nproduce @M(projx(0)+2*ticklength,projy(cytick)) Label(str(cytick))
        cytick += ytick
    nproduce ]


# We consider as cell i the bud and cell j the internode.

"""
Note: 
  - The concentration of ci control the magnitude of s shape of the curve
  - Parameter values of the simulation
  FigS2 A : cj = 10; deltacicj = -5 (ci = 5)
  FigS2 B : cj = 10; deltacicj = 2  (ci = 12)
  FigS2 C : cj = 5;  deltacicj = 7  (ci = 12)
  FigS2 D : same as FigS2 B except not the same equilibrium point is reached.
  
"""

active_transport_coef = 0.5 # T
diffusion_coef = 0.1 # D

# parameter of the flux feedback function
h_coef = 7.5 # rho_i->j in the paper
# non linear exponent of the flux feedback function
n = 3
# hill saturation coef
K = 1.3

#apical_bud_auxin_synth_coef = 10
#lateral_bud_auxin_synth_coef = 10.0  # for lapex
#residual_auxin_synth_coef = 0.0 # \rho (c_i)

# auxin_degrad_coef = 0.005 #

pin_synth_coeff = 0.0 # rho_0
pin_degrad_coeff = 10  # \mu

#deltacicj = -5
ci = cj + deltacicj
pinij, pinji = 0.7, 0


def h(flux) :
  if flux < 0.:  return 0.

  fluxn = abs(flux) ** n
  return h_coef * (fluxn / (K**n + fluxn))


def txt(val):
    return str(round(val,2))[:5]


def dfluxij(fluxij,ci,cj):
  selfenhancingterm = active_transport_coef * ci * h(fluxij)
  
  degradationterm = - pin_degrad_coeff * (fluxij)
  
  diffusionterm = (pin_degrad_coeff * diffusion_coef + pin_synth_coeff*active_transport_coef)*(ci - cj)
  
  result = 0
  if fluxij > 0.:
     result =  selfenhancingterm 
  if DEGRADATION:
     result += degradationterm 
  if DIFFUSION:
     result += diffusionterm
  return result


#def fluxij(ci,cj,pinij,pinji):
#    return active_transport_coef * (pinij *ci - pinji *cj) +  diffusion_coef * (ci-cj)


Axiom: A
production:

interpretation:

A :
   fluxvalues = arange(-3,6,0.1)
   
   dfvalues  = map(lambda f: dfluxij(f,ci,cj),fluxvalues)
   plotCurve((fluxvalues,dfvalues),yextend=(min(-30,min(dfvalues)),max(40,max(dfvalues))),pos = (-0.9,-0.9), dim = (1.2,1.6))
   
   
#   cjvalues = arange(0,30.01,1.)
#   fvalues  = map(lambda c: fluxij(ci,c,pinij, pinji),cjvalues)
#   
#   print max(fvalues), min(fvalues)
#   yextend=(min(-2,min(fvalues)),max(5,max(fvalues)+1))
#   print yextend
#   plotCurve((cjvalues,fvalues),pos=(0.1,0.1),yextend=yextend )

endlsystem



###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (39,0,0) , diffuse = 4.61538 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_1 = pgl.Material("Color_1" , ambient = (40,5,0) , diffuse = 4.518 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_2 = pgl.Material("Color_2" , ambient = (41,10,0) , diffuse = 4.42061 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (43,15,0) , diffuse = 4.32322 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (44,21,0) , diffuse = 4.22583 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_5 = pgl.Material("Color_5" , ambient = (46,26,0) , diffuse = 4.12845 , )
	Color_5.name = "Color_5"
	context.turtle.setMaterial(5,Color_5)
	Color_6 = pgl.Material("Color_6" , ambient = (47,31,0) , diffuse = 4.03106 , )
	Color_6.name = "Color_6"
	context.turtle.setMaterial(6,Color_6)
	Color_7 = pgl.Material("Color_7" , ambient = (48,37,0) , diffuse = 3.93367 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (50,42,0) , diffuse = 3.83628 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (51,47,0) , diffuse = 3.7389 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (53,53,0) , diffuse = 3.64151 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_15 = pgl.Material("Color_15" , ambient = (0,0,255) , diffuse = 0.627451 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (157,158,205) , diffuse = 0 , specular = (0,0,0) , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 26.6667 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (0,95,0) , diffuse = 0 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (128,193,96) , diffuse = 0 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	context.options.setSelection('Warning with sharp module',0)
	context.options.setSelection('Selection Always Required',1)
	scalars = [('DEGRADATION', 'Bool', True), ('DIFFUSION', 'Bool', True), ('cj', 'Integer', 5, -20, 50), ('deltacicj', 'Integer', 7, -20, 20)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
__copyright__ = 'open-source GPL'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'F. Boudon, C. Godin'
